
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>filmLibary: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">films_library/cmd/filmLibary/main.go (0.0%)</option>
				
				<option value="file1">films_library/config/config.go (0.0%)</option>
				
				<option value="file2">films_library/internal/actor/delivery/http/handler.go (0.0%)</option>
				
				<option value="file3">films_library/internal/actor/mocks/mocks.go (37.6%)</option>
				
				<option value="file4">films_library/internal/actor/repository/postgresql/repository.go (0.0%)</option>
				
				<option value="file5">films_library/internal/actor/usecase/usecase.go (94.4%)</option>
				
				<option value="file6">films_library/internal/app/app.go (0.0%)</option>
				
				<option value="file7">films_library/internal/film/delivery/http/handler.go (0.0%)</option>
				
				<option value="file8">films_library/internal/film/mocks/mocks.go (50.0%)</option>
				
				<option value="file9">films_library/internal/film/repository/postgresql/repository.go (9.1%)</option>
				
				<option value="file10">films_library/internal/film/usecase/usecase.go (100.0%)</option>
				
				<option value="file11">films_library/internal/middlware/allwedMethods.go (0.0%)</option>
				
				<option value="file12">films_library/internal/middlware/auth.go (0.0%)</option>
				
				<option value="file13">films_library/internal/middlware/logMW.go (0.0%)</option>
				
				<option value="file14">films_library/internal/middlware/recoverer.go (0.0%)</option>
				
				<option value="file15">films_library/internal/model/errors.go (0.0%)</option>
				
				<option value="file16">films_library/pkg/httpserver/option.go (0.0%)</option>
				
				<option value="file17">films_library/pkg/httpserver/server.go (0.0%)</option>
				
				<option value="file18">films_library/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file19">films_library/pkg/postgres/options.go (0.0%)</option>
				
				<option value="file20">films_library/pkg/postgres/postgres.go (0.0%)</option>
				
				<option value="file21">films_library/pkg/response/response.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"

        "films_library/config"
        "films_library/internal/app"

        "github.com/joho/godotenv"
)

// @title Go Film Libary REST API
// @version 1.0
// @description Golang REST API  for managing films, directors and actors in a film library database.
// @contact.name Grigory Kovalenko
// @contact.url https://github.com/CodeMaster482
// @contact.email grigorikovalenko@gmail.com
// @BasePath /api/v1
func main() <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to load .env file")
                return
        }</span>

        <span class="cov0" title="0">cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Config error: %s", err)
        }</span>

        <span class="cov0" title="0">fmt.Println(cfg)

        app.Run(cfg)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"

        "github.com/ilyakaznacheev/cleanenv"
)

type (
        // Config -.
        Config struct {
                App  `yaml:"app"`
                HTTP `yaml:"http"`
                Log  `yaml:"logger"`
                PG   `yaml:"postgres"`
        }

        // App -.
        App struct {
                Name    string `env-required:"true" yaml:"name"    env:"APP_NAME"`
                Version string `env-required:"true" yaml:"version" env:"APP_VERSION"`
        }

        // HTTP -.
        HTTP struct {
                Port string `env-required:"true" yaml:"port" env:"HTTP_PORT"`
        }

        // Log -.
        Log struct {
                Level string `env-required:"true" yaml:"log_level"   env:"LOG_LEVEL"`
        }

        // PG -.
        PG struct {
                Name     string `env:"DB_NAME"`
                User     string `env:"DB_USER"`
                Port     int    `env:"DB_PORT"`
                Password string `env:"DB_PASSWORD"`
                Host     string `env:"DB_HOST"`
                PoolMax  int    `yaml:"pool_max"`
        }
)

func NewConfig() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{}

        err := cleanenv.ReadConfig("./config/config.yml", cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config error: %w", err)
        }</span>

        <span class="cov0" title="0">err = cleanenv.ReadEnv(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "errors"
        "net/http"
        "strconv"

        "films_library/internal/actor"
        "films_library/internal/model"
        "films_library/pkg/logger"
        "films_library/pkg/response"

        "github.com/go-playground/validator"
        "github.com/jackc/pgx/v4"
        "github.com/mailru/easyjson"
)

type ActorHandler struct {
        actorUsecase actor.Usecase
        logger       logger.Interface
}

func NewActorHandler(mux *http.ServeMux, au actor.Usecase, l logger.Interface) <span class="cov0" title="0">{
        r := &amp;ActorHandler{au, l}

        mux.HandleFunc("/actor", r.GetActor)
        mux.HandleFunc("/actor/add", r.AddActor)
        mux.HandleFunc("/actor/update", r.UpdateActor)
        mux.HandleFunc("/actor/delete", r.DeleteActor)
}</span>

func (h *ActorHandler) GetActor(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        actors, err := h.actorUsecase.GetActors(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusInternalServerError, "Internal server error", h.logger)
                return
        }</span>

        <span class="cov0" title="0">response.SuccessResponse(w, http.StatusOK, actors)</span>
}

func (h *ActorHandler) AddActor(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var actor model.Actor
        if err := easyjson.UnmarshalFromReader(r.Body, &amp;actor); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Corrupted request body", h.logger)
                return
        }</span>

        <span class="cov0" title="0">v := validator.New()
        if err := v.Struct(actor); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Invalid request", h.logger)
                return
        }</span>

        <span class="cov0" title="0">id, err := h.actorUsecase.AddActor(r.Context(), &amp;actor)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusInternalServerError, "Internal server error", h.logger)
                return
        }</span>

        <span class="cov0" title="0">response.SuccessResponse(w, http.StatusOK, id)</span>
}

func (h *ActorHandler) UpdateActor(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var actor model.Actor
        if err := easyjson.UnmarshalFromReader(r.Body, &amp;actor); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Corrupted request body", h.logger)
                return
        }</span>

        <span class="cov0" title="0">v := validator.New()
        if err := v.Struct(actor); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Invalid request", h.logger)
                return
        }</span>

        <span class="cov0" title="0">updatedActor, err := h.actorUsecase.UpdateActor(r.Context(), &amp;actor)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        h.logger.Info("user bad request: %s", err)
                        response.ErrorResponse(w, http.StatusInternalServerError, "Object don't exist", h.logger)
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error(err)
                response.ErrorResponse(w, http.StatusInternalServerError, "Internal server error", h.logger)
                return</span>
        }

        <span class="cov0" title="0">response.SuccessResponse(w, http.StatusOK, updatedActor)</span>
}

func (h *ActorHandler) DeleteActor(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idParam := r.URL.Query().Get("id")
        actorId, err := strconv.Atoi(idParam)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Bad query param", h.logger)
                return
        }</span>

        <span class="cov0" title="0">if actorId &lt; 0 </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Invalid request", h.logger)
                return
        }</span>

        <span class="cov0" title="0">id, err := h.actorUsecase.DeleteActor(r.Context(), 1)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        h.logger.Info("user bad request: %s", err)
                        response.ErrorResponse(w, http.StatusInternalServerError, "Object don't exist", h.logger)
                        return
                }</span>
                <span class="cov0" title="0">h.logger.Error(err)
                response.ErrorResponse(w, http.StatusInternalServerError, "Internal server error", h.logger)
                return</span>
        }

        <span class="cov0" title="0">response.SuccessResponse(w, http.StatusOK, id)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/actor/actor.go

// Package mock_actor is a generated GoMock package.
package mock_actor

import (
        context "context"
        model "films_library/internal/model"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUsecase is a mock of Usecase interface.
type MockUsecase struct {
        ctrl     *gomock.Controller
        recorder *MockUsecaseMockRecorder
}

// MockUsecaseMockRecorder is the mock recorder for MockUsecase.
type MockUsecaseMockRecorder struct {
        mock *MockUsecase
}

// NewMockUsecase creates a new mock instance.
func NewMockUsecase(ctrl *gomock.Controller) *MockUsecase <span class="cov0" title="0">{
        mock := &amp;MockUsecase{ctrl: ctrl}
        mock.recorder = &amp;MockUsecaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUsecase) EXPECT() *MockUsecaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddActor mocks base method.
func (m *MockUsecase) AddActor(ctx context.Context, actor *model.Actor) (uint, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddActor", ctx, actor)
        ret0, _ := ret[0].(uint)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddActor indicates an expected call of AddActor.
func (mr *MockUsecaseMockRecorder) AddActor(ctx, actor interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddActor", reflect.TypeOf((*MockUsecase)(nil).AddActor), ctx, actor)
}</span>

// CheckActors mocks base method.
func (m *MockUsecase) CheckActors(ctx context.Context, actors []uint) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckActors", ctx, actors)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CheckActors indicates an expected call of CheckActors.
func (mr *MockUsecaseMockRecorder) CheckActors(ctx, actors interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckActors", reflect.TypeOf((*MockUsecase)(nil).CheckActors), ctx, actors)
}</span>

// DeleteActor mocks base method.
func (m *MockUsecase) DeleteActor(ctx context.Context, actorID uint) (uint, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteActor", ctx, actorID)
        ret0, _ := ret[0].(uint)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteActor indicates an expected call of DeleteActor.
func (mr *MockUsecaseMockRecorder) DeleteActor(ctx, actorID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteActor", reflect.TypeOf((*MockUsecase)(nil).DeleteActor), ctx, actorID)
}</span>

// GetActors mocks base method.
func (m *MockUsecase) GetActors(ctx context.Context) ([]model.ResponseActor, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetActors", ctx)
        ret0, _ := ret[0].([]model.ResponseActor)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetActors indicates an expected call of GetActors.
func (mr *MockUsecaseMockRecorder) GetActors(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActors", reflect.TypeOf((*MockUsecase)(nil).GetActors), ctx)
}</span>

// UpdateActor mocks base method.
func (m *MockUsecase) UpdateActor(ctx context.Context, actor *model.Actor) (*model.Actor, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateActor", ctx, actor)
        ret0, _ := ret[0].(*model.Actor)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateActor indicates an expected call of UpdateActor.
func (mr *MockUsecaseMockRecorder) UpdateActor(ctx, actor interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateActor", reflect.TypeOf((*MockUsecase)(nil).UpdateActor), ctx, actor)
}</span>

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov8" title="1">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddActor mocks base method.
func (m *MockRepository) AddActor(ctx context.Context, actor *model.Actor) (uint, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddActor", ctx, actor)
        ret0, _ := ret[0].(uint)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddActor indicates an expected call of AddActor.
func (mr *MockRepositoryMockRecorder) AddActor(ctx, actor interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddActor", reflect.TypeOf((*MockRepository)(nil).AddActor), ctx, actor)
}</span>

// CheckActor mocks base method.
func (m *MockRepository) CheckActor(ctx context.Context, actor uint) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CheckActor", ctx, actor)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CheckActor indicates an expected call of CheckActor.
func (mr *MockRepositoryMockRecorder) CheckActor(ctx, actor interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckActor", reflect.TypeOf((*MockRepository)(nil).CheckActor), ctx, actor)
}</span>

// DeleteActor mocks base method.
func (m *MockRepository) DeleteActor(ctx context.Context, actorID uint) (uint, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteActor", ctx, actorID)
        ret0, _ := ret[0].(uint)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteActor indicates an expected call of DeleteActor.
func (mr *MockRepositoryMockRecorder) DeleteActor(ctx, actorID interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteActor", reflect.TypeOf((*MockRepository)(nil).DeleteActor), ctx, actorID)
}</span>

// GetActor mocks base method.
func (m *MockRepository) GetActor(ctx context.Context, actorID uint) (model.Actor, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetActor", ctx, actorID)
        ret0, _ := ret[0].(model.Actor)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetActor indicates an expected call of GetActor.
func (mr *MockRepositoryMockRecorder) GetActor(ctx, actorID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActor", reflect.TypeOf((*MockRepository)(nil).GetActor), ctx, actorID)
}</span>

// GetActors mocks base method.
func (m *MockRepository) GetActors(ctx context.Context) ([]model.ResponseActor, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetActors", ctx)
        ret0, _ := ret[0].([]model.ResponseActor)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetActors indicates an expected call of GetActors.
func (mr *MockRepositoryMockRecorder) GetActors(ctx interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActors", reflect.TypeOf((*MockRepository)(nil).GetActors), ctx)
}</span>

// UpdateActor mocks base method.
func (m *MockRepository) UpdateActor(ctx context.Context, actor *model.Actor) (*model.Actor, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateActor", ctx, actor)
        ret0, _ := ret[0].(*model.Actor)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateActor indicates an expected call of UpdateActor.
func (mr *MockRepositoryMockRecorder) UpdateActor(ctx, actor interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateActor", reflect.TypeOf((*MockRepository)(nil).UpdateActor), ctx, actor)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package postgres

import (
        "context"
        "films_library/internal/model"
        "films_library/pkg/postgres"
)

type Repository struct {
        db postgres.DBConn
}

func NewRepository(db postgres.DBConn) *Repository <span class="cov0" title="0">{
        return &amp;Repository{db}
}</span>

func (ar *Repository) AddActor(ctx context.Context, actor *model.Actor) (uint, error) <span class="cov0" title="0">{
        sqlQuery := `INSERT INTO actor (name, sex, birth_date) VALUES ($1, $2, $3) RETURNING id`

        var id uint
        if err := ar.db.QueryRow(ctx, sqlQuery,
                actor.Name,
                actor.Sex,
                actor.BirthDate,
        ).Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

func (ar *Repository) UpdateActor(ctx context.Context, actor *model.Actor) (*model.Actor, error) <span class="cov0" title="0">{
        sqlQuery := `UPDATE actor SET name = $1, sex = $2, birth_date = $3 WHERE id = $4 RETURNING id`

        var id uint
        if err := ar.db.QueryRow(ctx, sqlQuery,
                actor.Name,
                actor.Sex,
                actor.BirthDate,
                actor.ID,
        ).Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;model.ErrNotFound{}
        }</span>
        <span class="cov0" title="0">return actor, nil</span>
}

func (ar *Repository) DeleteActor(ctx context.Context, actorID uint) (uint, error) <span class="cov0" title="0">{
        sqlQuery := `DELETE FROM actor WHERE id = $1 RETURNING id`

        var id uint
        if err := ar.db.QueryRow(ctx, sqlQuery, actorID).Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                return 0, &amp;model.ErrNotFound{}
        }</span>
        <span class="cov0" title="0">return id, nil</span>

}

func (ar *Repository) GetActor(ctx context.Context, actorID uint) (model.Actor, error) <span class="cov0" title="0">{
        sqlQuery := `SELECT id, name, sex, birth_date FROM actor WHERE id = $1`
        row := ar.db.QueryRow(ctx, sqlQuery, actorID)
        var actor model.Actor
        if err := row.Scan(
                &amp;actor.ID,
                &amp;actor.Name,
                &amp;actor.Sex,
                &amp;actor.BirthDate,
        ); err != nil </span><span class="cov0" title="0">{
                return model.Actor{}, err
        }</span>
        <span class="cov0" title="0">return actor, nil</span>
}

func (ar *Repository) GetActors(ctx context.Context) ([]model.ResponseActor, error) <span class="cov0" title="0">{
        sqlQuery := `SELECT id, name, sex, birth_date FROM actor;`
        subQuery := ` SELECT fa.movie_id, f.title
                                        FROM film_actor AS fa
                                        JOIN film f ON f.movie_id = fa.movie_id WHERE fa.actor_id = $1;`

        rows, err := ar.db.Query(ctx, sqlQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var actors []model.ResponseActor
        for rows.Next() </span><span class="cov0" title="0">{
                var actor model.ResponseActor
                if err := rows.Scan(
                        &amp;actor.ActorID,
                        &amp;actor.Name,
                        &amp;actor.Sex,
                        &amp;actor.BirthDate,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">rowsFilms, err := ar.db.Query(ctx, subQuery, actor.ActorID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for rowsFilms.Next() </span><span class="cov0" title="0">{
                        var film model.FilmObj
                        if err := rowsFilms.Scan(
                                &amp;film.Id,
                                &amp;film.Title,
                        ); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">actor.Films = append(actor.Films, film)</span>
                }
                <span class="cov0" title="0">if err := rowsFilms.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">actors = append(actors, actor)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return actors, nil</span>
}

func (ar *Repository) CheckActor(ctx context.Context, actor uint) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package usecase

import (
        "context"
        "films_library/internal/actor"
        "films_library/internal/model"
        "films_library/pkg/logger"
)

type Usecase struct {
        actorRepo actor.Repository
        logger    logger.Interface
}

func NewActorUsecase(ar actor.Repository, l logger.Interface) *Usecase <span class="cov8" title="1">{
        return &amp;Usecase{ar, l}
}</span>

func (au *Usecase) AddActor(ctx context.Context, actor *model.Actor) (uint, error) <span class="cov8" title="1">{
        id, err := au.actorRepo.AddActor(ctx, actor)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return id, nil</span>
}

func (au *Usecase) UpdateActor(ctx context.Context, actor *model.Actor) (*model.Actor, error) <span class="cov8" title="1">{
        updatedActor, err := au.actorRepo.UpdateActor(ctx, actor)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return updatedActor, nil</span>
}

func (au *Usecase) DeleteActor(ctx context.Context, actorID uint) (uint, error) <span class="cov8" title="1">{
        id, err := au.actorRepo.DeleteActor(ctx, actorID)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return id, nil</span>
}

func (au *Usecase) GetActors(ctx context.Context) ([]model.ResponseActor, error) <span class="cov8" title="1">{
        actors, err := au.actorRepo.GetActors(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return []model.ResponseActor{}, err
        }</span>
        <span class="cov8" title="1">return actors, nil</span>
}

func (au *Usecase) CheckActors(ctx context.Context, actors []uint) (bool, error) <span class="cov0" title="0">{
        // exist, err := au.actorRepo.CheckActors(ctx, actors)
        // if err != nil {
        //         return false, err
        // }
        return false, nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package app

import (
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"

        "films_library/config"
        actorDelivery "films_library/internal/actor/delivery/http"
        actorRep "films_library/internal/actor/repository/postgresql"
        actorUsecase "films_library/internal/actor/usecase"
        filmDelivery "films_library/internal/film/delivery/http"
        filmRep "films_library/internal/film/repository/postgresql"
        filmUsecase "films_library/internal/film/usecase"
        "films_library/internal/middlware"
        "films_library/pkg/httpserver"
        "films_library/pkg/logger"
        "films_library/pkg/postgres"
)

func Run(cfg *config.Config) <span class="cov0" title="0">{
        l := logger.New(cfg.Log.Level)

        // Repository
        pg, err := postgres.New(
                cfg.PG.Host,
                cfg.PG.User,
                cfg.PG.Password,
                cfg.PG.Name,
                cfg.PG.Port,
                postgres.MaxPoolSize(cfg.PG.PoolMax),
        )
        if err != nil </span><span class="cov0" title="0">{
                l.Fatal(fmt.Errorf("app - Run - postgres.New: %w", err))
        }</span>
        <span class="cov0" title="0">defer pg.Close()

        // Usecase
        actorRepo := actorRep.NewRepository(pg.Pool)
        actorUsecase := actorUsecase.NewActorUsecase(actorRepo, l)

        filmRepo := filmRep.NewRepository(pg.Pool)
        filmUsecase := filmUsecase.NewFilmUsecase(filmRepo, l)

        // Middleware

        recoveryMW := middlware.NewRecoveryMiddleware(l)
        logMW := middlware.NewLoggingMiddleware(l)

        // HTTP Server
        mux := http.NewServeMux()

        filmDelivery.NewFilmHandler(mux, filmUsecase, l)
        actorDelivery.NewActorHandler(mux, actorUsecase, l)

        r := recoveryMW.Recoverer(mux)
        r = logMW.LoggingMiddleware(r)
        r = middlware.AllowedMethod(r)
        r = middlware.Authentication(r)

        httpServer := httpserver.New(r, httpserver.Port(cfg.HTTP.Port))

        // Waiting signal
        interrupt := make(chan os.Signal, 1)
        signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)

        select </span>{
        case s := &lt;-interrupt:<span class="cov0" title="0">
                l.Info("app - Run - signal: " + s.String())</span>
        case err = &lt;-httpServer.Notify():<span class="cov0" title="0">
                l.Error(fmt.Errorf("app - Run - httpServer.Notify: %w", err))</span>
        }

        // Shutdown
        <span class="cov0" title="0">err = httpServer.Shutdown()
        if err != nil </span><span class="cov0" title="0">{
                l.Error(fmt.Errorf("app - Run - httpServer.Shutdown: %w", err))
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package http

import (
        "net/http"
        "strconv"

        "films_library/internal/film"
        "films_library/internal/model"
        "films_library/pkg/logger"
        "films_library/pkg/response"

        "github.com/go-playground/validator/v10"
        "github.com/mailru/easyjson"
)

type FilmHandler struct {
        filmUsecase film.Usecase
        logger      logger.Interface
}

func NewFilmHandler(mux *http.ServeMux, fu film.Usecase, l logger.Interface) <span class="cov0" title="0">{
        r := &amp;FilmHandler{fu, l}

        mux.HandleFunc("/film", r.GetFilms)
        mux.HandleFunc("/film/add", r.AddFilm)
        mux.HandleFunc("/film/update", r.UpdateFilm)
        mux.HandleFunc("/film/delete", r.DeleteFilm)
        mux.HandleFunc("/film/search", r.SearchFilm)
}</span>

func (h *FilmHandler) GetFilms(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        queryParams := r.URL.Query()

        sortBy := queryParams.Get("sort_by")
        sortOrder := queryParams.Get("sort_order")

        if sortBy == "" </span><span class="cov0" title="0">{
                sortBy = "rating"
        }</span>
        <span class="cov0" title="0">if sortOrder == "" </span><span class="cov0" title="0">{
                sortOrder = "desc"
        }</span>

        <span class="cov0" title="0">filter := model.FilmFilter{
                SortBy:    sortBy,
                SortOrder: sortOrder,
        }

        v := validator.New()
        if err := v.Struct(filter); err != nil </span><span class="cov0" title="0">{
                filter.SortBy = "rating"
                filter.SortOrder = "desc"
        }</span>

        <span class="cov0" title="0">films, err := h.filmUsecase.GetFilms(r.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusInternalServerError, "Internal server error", h.logger)
                return
        }</span>

        <span class="cov0" title="0">response.SuccessResponse(w, http.StatusOK, films)</span>
}

func (h *FilmHandler) AddFilm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var film model.AddFilmRequest
        if err := easyjson.UnmarshalFromReader(r.Body, &amp;film); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Corrupted request body", h.logger)
                return
        }</span>

        <span class="cov0" title="0">v := validator.New()
        if err := v.Struct(film); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Invalid request", h.logger)
                return
        }</span>

        <span class="cov0" title="0">id, err := h.filmUsecase.AddFilm(r.Context(), film)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusInternalServerError, "Internal server error", h.logger)
                return
        }</span>
        <span class="cov0" title="0">response.SuccessResponse(w, http.StatusCreated, id)</span>
}

func (h *FilmHandler) UpdateFilm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var film model.Film
        if err := easyjson.UnmarshalFromReader(r.Body, &amp;film); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Corrupted request body", h.logger)
                return
        }</span>

        <span class="cov0" title="0">v := validator.New()
        if err := v.Struct(film); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Invalid request", h.logger)
                return
        }</span>

        <span class="cov0" title="0">id, err := h.filmUsecase.UpdateFilm(r.Context(), film)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusInternalServerError, "Internal server error", h.logger)
                return
        }</span>
        <span class="cov0" title="0">response.SuccessResponse(w, http.StatusOK, id)</span>
}

func (h *FilmHandler) DeleteFilm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idParam := r.URL.Query().Get("id")
        filmId, err := strconv.Atoi(idParam)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Bad query param", h.logger)
                return
        }</span>

        <span class="cov0" title="0">if filmId &lt; 0 </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusBadRequest, "Invalid request", h.logger)
                return
        }</span>

        <span class="cov0" title="0">id, err := h.filmUsecase.DeleteFilm(r.Context(), uint64(filmId))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusInternalServerError, "Internal server error", h.logger)
                return
        }</span>
        <span class="cov0" title="0">response.SuccessResponse(w, http.StatusOK, id)</span>
}

func (h *FilmHandler) SearchFilm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        queryParams := r.URL.Query()
        search := queryParams.Get("search")

        if search == "" </span><span class="cov0" title="0">{
                h.logger.Error("Empty title")
                response.ErrorResponse(w, http.StatusBadRequest, "Empty title", h.logger)
                return
        }</span>

        <span class="cov0" title="0">film, err := h.filmUsecase.SearchFilm(r.Context(), search)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(err)
                response.ErrorResponse(w, http.StatusInternalServerError, "Internal server error", h.logger)
                return
        }</span>
        <span class="cov0" title="0">response.SuccessResponse(w, http.StatusOK, film)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/film/film.go

// Package mock_film is a generated GoMock package.
package mock_film

import (
        context "context"
        model "films_library/internal/model"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUsecase is a mock of Usecase interface.
type MockUsecase struct {
        ctrl     *gomock.Controller
        recorder *MockUsecaseMockRecorder
}

// MockUsecaseMockRecorder is the mock recorder for MockUsecase.
type MockUsecaseMockRecorder struct {
        mock *MockUsecase
}

// NewMockUsecase creates a new mock instance.
func NewMockUsecase(ctrl *gomock.Controller) *MockUsecase <span class="cov0" title="0">{
        mock := &amp;MockUsecase{ctrl: ctrl}
        mock.recorder = &amp;MockUsecaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUsecase) EXPECT() *MockUsecaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddFilm mocks base method.
func (m *MockUsecase) AddFilm(ctx context.Context, film model.AddFilmRequest) (uint64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddFilm", ctx, film)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddFilm indicates an expected call of AddFilm.
func (mr *MockUsecaseMockRecorder) AddFilm(ctx, film interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddFilm", reflect.TypeOf((*MockUsecase)(nil).AddFilm), ctx, film)
}</span>

// DeleteFilm mocks base method.
func (m *MockUsecase) DeleteFilm(ctx context.Context, id uint64) (uint64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteFilm", ctx, id)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteFilm indicates an expected call of DeleteFilm.
func (mr *MockUsecaseMockRecorder) DeleteFilm(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteFilm", reflect.TypeOf((*MockUsecase)(nil).DeleteFilm), ctx, id)
}</span>

// GetFilm mocks base method.
func (m *MockUsecase) GetFilm(ctx context.Context, id uint64) (model.Film, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFilm", ctx, id)
        ret0, _ := ret[0].(model.Film)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFilm indicates an expected call of GetFilm.
func (mr *MockUsecaseMockRecorder) GetFilm(ctx, id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFilm", reflect.TypeOf((*MockUsecase)(nil).GetFilm), ctx, id)
}</span>

// GetFilms mocks base method.
func (m *MockUsecase) GetFilms(ctx context.Context, filter model.FilmFilter) ([]model.Film, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFilms", ctx, filter)
        ret0, _ := ret[0].([]model.Film)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFilms indicates an expected call of GetFilms.
func (mr *MockUsecaseMockRecorder) GetFilms(ctx, filter interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFilms", reflect.TypeOf((*MockUsecase)(nil).GetFilms), ctx, filter)
}</span>

// SearchFilm mocks base method.
func (m *MockUsecase) SearchFilm(ctx context.Context, search string) ([]model.Film, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchFilm", ctx, search)
        ret0, _ := ret[0].([]model.Film)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchFilm indicates an expected call of SearchFilm.
func (mr *MockUsecaseMockRecorder) SearchFilm(ctx, search interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchFilm", reflect.TypeOf((*MockUsecase)(nil).SearchFilm), ctx, search)
}</span>

// UpdateFilm mocks base method.
func (m *MockUsecase) UpdateFilm(ctx context.Context, film model.Film) (uint64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateFilm", ctx, film)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateFilm indicates an expected call of UpdateFilm.
func (mr *MockUsecaseMockRecorder) UpdateFilm(ctx, film interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateFilm", reflect.TypeOf((*MockUsecase)(nil).UpdateFilm), ctx, film)
}</span>

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov8" title="1">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AddFilm mocks base method.
func (m *MockRepository) AddFilm(ctx context.Context, film model.AddFilmRequest) (uint64, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddFilm", ctx, film)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AddFilm indicates an expected call of AddFilm.
func (mr *MockRepositoryMockRecorder) AddFilm(ctx, film interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddFilm", reflect.TypeOf((*MockRepository)(nil).AddFilm), ctx, film)
}</span>

// DeleteFilm mocks base method.
func (m *MockRepository) DeleteFilm(ctx context.Context, id uint64) (uint64, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteFilm", ctx, id)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteFilm indicates an expected call of DeleteFilm.
func (mr *MockRepositoryMockRecorder) DeleteFilm(ctx, id interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteFilm", reflect.TypeOf((*MockRepository)(nil).DeleteFilm), ctx, id)
}</span>

// GetFilm mocks base method.
func (m *MockRepository) GetFilm(ctx context.Context, id uint64) (model.Film, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFilm", ctx, id)
        ret0, _ := ret[0].(model.Film)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFilm indicates an expected call of GetFilm.
func (mr *MockRepositoryMockRecorder) GetFilm(ctx, id interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFilm", reflect.TypeOf((*MockRepository)(nil).GetFilm), ctx, id)
}</span>

// GetFilms mocks base method.
func (m *MockRepository) GetFilms(ctx context.Context, filter model.FilmFilter) ([]model.Film, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFilms", ctx, filter)
        ret0, _ := ret[0].([]model.Film)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFilms indicates an expected call of GetFilms.
func (mr *MockRepositoryMockRecorder) GetFilms(ctx, filter interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFilms", reflect.TypeOf((*MockRepository)(nil).GetFilms), ctx, filter)
}</span>

// SearchFilm mocks base method.
func (m *MockRepository) SearchFilm(ctx context.Context, search string) ([]model.Film, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SearchFilm", ctx, search)
        ret0, _ := ret[0].([]model.Film)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SearchFilm indicates an expected call of SearchFilm.
func (mr *MockRepositoryMockRecorder) SearchFilm(ctx, search interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchFilm", reflect.TypeOf((*MockRepository)(nil).SearchFilm), ctx, search)
}</span>

// UpdateFilm mocks base method.
func (m *MockRepository) UpdateFilm(ctx context.Context, film model.Film) (uint64, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateFilm", ctx, film)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateFilm indicates an expected call of UpdateFilm.
func (mr *MockRepositoryMockRecorder) UpdateFilm(ctx, film interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateFilm", reflect.TypeOf((*MockRepository)(nil).UpdateFilm), ctx, film)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package postgresql

import (
        "context"
        "films_library/internal/model"
        "films_library/pkg/postgres"
        "fmt"
)

type Repository struct {
        db postgres.DBConn
}

func NewRepository(db postgres.DBConn) *Repository <span class="cov8" title="1">{
        return &amp;Repository{db}
}</span>

func (r *Repository) GetFilms(ctx context.Context, filter model.FilmFilter) ([]model.Film, error) <span class="cov0" title="0">{
        sqlQuery := `SELECT film_id, title, "description", release_date, rating FROM film`

        if filter.SortBy != "" </span><span class="cov0" title="0">{
                sqlQuery += " ORDER BY " + filter.SortBy
                if filter.SortOrder == "desc" </span><span class="cov0" title="0">{
                        sqlQuery += " DESC"
                }</span> else<span class="cov0" title="0"> {
                        sqlQuery += " ASC"
                }</span>
        }

        <span class="cov0" title="0">rows, err := r.db.Query(ctx, sqlQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var films []model.Film
        for rows.Next() </span><span class="cov0" title="0">{
                var film model.Film
                if err := rows.Scan(
                        &amp;film.ID,
                        &amp;film.Title,
                        &amp;film.Description,
                        &amp;film.ReleaseDate,
                        &amp;film.Rating,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fmt.Println(film)
                films = append(films, film)</span>
        }
        <span class="cov0" title="0">return films, nil</span>
}

func (r *Repository) GetFilm(ctx context.Context, id uint64) (model.Film, error) <span class="cov0" title="0">{
        sqlQuery := `SELECT (film_id, title, "description", release_date, rating) FROM film WHERE film_id=$1`

        row := r.db.QueryRow(ctx, sqlQuery, id)
        var film model.Film
        err := row.Scan(&amp;film.ID, &amp;film.Title, &amp;film.Description, &amp;film.ReleaseDate, &amp;film.Rating)
        if err != nil </span><span class="cov0" title="0">{
                return model.Film{}, err
        }</span>
        <span class="cov0" title="0">return film, nil</span>
}

func (r *Repository) AddFilm(ctx context.Context, film model.AddFilmRequest) (uint64, error) <span class="cov0" title="0">{
        sqlQuery := `INSERT INTO film (title, "description", release_date, rating) VALUES ($1, $2, $3, $4) RETURNING film_id`
        var id uint64
        err := r.db.QueryRow(ctx, sqlQuery, film.Title, film.Description, film.ReleaseDate, film.Rating).Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

func (r *Repository) UpdateFilm(ctx context.Context, film model.Film) (uint64, error) <span class="cov8" title="1">{
        sqlQuery := `UPDATE film SET title=$1, "description"=$2, release_date=$3, rating=$4 WHERE film_id=$5 RETURNING film_id`

        var filmId uint64

        if err := r.db.QueryRow(ctx, sqlQuery,
                film.Title,
                film.Description,
                film.ReleaseDate,
                film.Rating,
                film.ID,
        ).Scan(&amp;filmId); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return filmId, nil</span>
}

func (r *Repository) DeleteFilm(ctx context.Context, id uint64) (uint64, error) <span class="cov0" title="0">{
        sqlQuery := `DELETE FROM film WHERE film_id=$1`
        res, err := r.db.Exec(ctx, sqlQuery, id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">rowsAffected := res.RowsAffected()
        return uint64(rowsAffected), nil</span>

}

func (r *Repository) SearchFilm(ctx context.Context, search string) ([]model.Film, error) <span class="cov0" title="0">{
        sqlQuery := `
        SELECT DISTINCT f.film_id, f.title, f.description, f.release_date, f.rating
        FROM film f
        JOIN film_actor fa ON f.film_id = fa.film_id
        JOIN actor a ON fa.actor_id = a.actor_id
        WHERE f.title LIKE '%' || $1 || '%'
        OR a.name LIKE '%' || $1 || '%'
    `

        rows, err := r.db.Query(ctx, sqlQuery, search)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var films []model.Film
        for rows.Next() </span><span class="cov0" title="0">{
                var film model.Film
                if err := rows.Scan(
                        &amp;film.ID,
                        &amp;film.Title,
                        &amp;film.Description,
                        &amp;film.ReleaseDate,
                        &amp;film.Rating,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">films = append(films, film)</span>
        }
        <span class="cov0" title="0">return films, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package usecase

import (
        "context"

        "films_library/internal/film"
        "films_library/internal/model"
        "films_library/pkg/logger"
)

type FilmUsecase struct {
        FilmRepository film.Repository
        logger         logger.Interface
}

func NewFilmUsecase(fr film.Repository, l logger.Interface) *FilmUsecase <span class="cov8" title="1">{
        return &amp;FilmUsecase{fr, l}
}</span>

func (fu *FilmUsecase) GetFilms(ctx context.Context, filter model.FilmFilter) ([]model.Film, error) <span class="cov8" title="1">{
        films, err := fu.FilmRepository.GetFilms(ctx, filter)
        if err != nil </span><span class="cov8" title="1">{
                return []model.Film{}, err
        }</span>
        <span class="cov8" title="1">return films, nil</span>
}

func (fu *FilmUsecase) AddFilm(ctx context.Context, film model.AddFilmRequest) (uint64, error) <span class="cov8" title="1">{
        id, err := fu.FilmRepository.AddFilm(ctx, film)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return id, nil</span>
}

func (fu *FilmUsecase) UpdateFilm(ctx context.Context, film model.Film) (uint64, error) <span class="cov8" title="1">{
        id, err := fu.FilmRepository.UpdateFilm(ctx, film)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return id, nil</span>
}

func (fu *FilmUsecase) DeleteFilm(ctx context.Context, id uint64) (uint64, error) <span class="cov8" title="1">{
        id, err := fu.FilmRepository.DeleteFilm(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return id, nil</span>
}

func (fu *FilmUsecase) GetFilm(ctx context.Context, id uint64) (model.Film, error) <span class="cov8" title="1">{
        film, err := fu.FilmRepository.GetFilm(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return model.Film{}, err
        }</span>
        <span class="cov8" title="1">return film, nil</span>
}

func (fu *FilmUsecase) SearchFilm(ctx context.Context, search string) ([]model.Film, error) <span class="cov8" title="1">{
        films, err := fu.FilmRepository.SearchFilm(ctx, search)
        if err != nil </span><span class="cov8" title="1">{
                return []model.Film{}, err
        }</span>
        <span class="cov8" title="1">return films, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middlware

import (
        "films_library/pkg/response"
        "net/http"
)

func AllowedMethod(next http.Handler) http.Handler <span class="cov0" title="0">{
        allowedEndpoints := map[string]map[string]bool{
                "/actor": {
                        "GET": true,
                },
                "/actor/add": {
                        "POST": true,
                },
                "/actor/update": {
                        "PUT": true,
                },
                "/actor/delete": {
                        "DELETE": true,
                },
                "/film/add": {
                        "POST": true,
                },
                "/film/update": {
                        "PUT": true,
                },
                "/film": {
                        "GET": true,
                },
                "/film/delete": {
                        "DELETE": true,
                },
                "/film/search": {
                        "GET": true,
                },
        }

        fn := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                allowedMethods, ok := allowedEndpoints[r.URL.Path]
                if !ok </span><span class="cov0" title="0">{
                        response.ErrorResponse(w, http.StatusNotFound, "Not found", nil)
                        return
                }</span>

                <span class="cov0" title="0">if !allowedMethods[r.Method] </span><span class="cov0" title="0">{
                        response.ErrorResponse(w, http.StatusMethodNotAllowed, "Method not allowed", nil)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })

        <span class="cov0" title="0">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package middlware

import (
        "films_library/pkg/response"
        "net/http"
)

func Authentication(next http.Handler) http.Handler <span class="cov0" title="0">{
        fn := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                cookie, err := r.Cookie("session_id")
                if err != nil || cookie == nil </span><span class="cov0" title="0">{
                        response.ErrorResponse(w, http.StatusUnauthorized, "missing token unauthorized", nil)
                        return
                }</span>

                <span class="cov0" title="0">if cookie.Value != "token_admin" || cookie.Name != "token_user" </span><span class="cov0" title="0">{
                        response.ErrorResponse(w, http.StatusUnauthorized, "invalid token", nil)
                        return
                }</span>

                <span class="cov0" title="0">if cookie.Value == "token_user" </span><span class="cov0" title="0">{
                        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                                response.ErrorResponse(w, http.StatusForbidden, "forbidden", nil)
                                return
                        }</span>
                }
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })

        <span class="cov0" title="0">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package middlware

import (
        "net/http"
        "time"

        "films_library/pkg/logger"

        "github.com/sirupsen/logrus"
)

type ResponseWriterWrap struct {
        http.ResponseWriter
        Status int
        Length int
}

func (r *ResponseWriterWrap) WriteHeader(status int) <span class="cov0" title="0">{
        r.Status = status
        r.ResponseWriter.WriteHeader(status)
}</span>

func (r *ResponseWriterWrap) Write(bytes []byte) (int, error) <span class="cov0" title="0">{
        r.Length = len(bytes)

        return r.ResponseWriter.Write(bytes)
}</span>

type LoggingMiddleware struct {
        log logger.Interface
}

func NewLoggingMiddleware(log logger.Interface) *LoggingMiddleware <span class="cov0" title="0">{
        return &amp;LoggingMiddleware{
                log: log,
        }
}</span>

func (m *LoggingMiddleware) LoggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                startTime := time.Now()
                wr := &amp;ResponseWriterWrap{
                        ResponseWriter: w,
                        Status:         200,
                }

                next.ServeHTTP(wr, r)

                status := wr.Status
                length := wr.Length

                midlog := m.log.WithFields(logrus.Fields{
                        "time":       time.Now(),
                        "duration":   time.Since(startTime),
                        "method":     r.Method,
                        "path":       r.URL.Path,
                        "status":     status,
                        "remote-IP":  r.RemoteAddr,
                        "byteLen":    length,
                        "user-agent": r.UserAgent(),
                })
                switch </span>{
                case status &gt;= http.StatusInternalServerError:<span class="cov0" title="0">
                        midlog.Error("Server Error")</span>
                case status &gt;= http.StatusBadRequest &amp;&amp; status &lt; http.StatusInternalServerError:<span class="cov0" title="0">
                        midlog.Warn("Client Error")</span>
                case status &gt;= http.StatusMultipleChoices &amp;&amp; status &lt; http.StatusBadRequest:<span class="cov0" title="0">
                        midlog.Info("Redirect")</span>
                case status &gt;= http.StatusOK &amp;&amp; status &lt; http.StatusMultipleChoices:<span class="cov0" title="0">
                        midlog.Info("Success")</span>
                default:<span class="cov0" title="0">
                        midlog.Info("Informational")</span>
                }
        }
        <span class="cov0" title="0">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middlware

import (
        "net/http"
        "runtime/debug"

        "films_library/pkg/logger"
)

type RecoveryMiddleware struct {
        log logger.Interface
}

func NewRecoveryMiddleware(log logger.Interface) *RecoveryMiddleware <span class="cov0" title="0">{
        return &amp;RecoveryMiddleware{
                log: log,
        }
}</span>

func (m *RecoveryMiddleware) Recoverer(next http.Handler) http.Handler <span class="cov0" title="0">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if rvr := recover(); rvr != nil </span><span class="cov0" title="0">{
                                if rvr == http.ErrAbortHandler </span><span class="cov0" title="0">{
                                        panic(rvr)</span>
                                }

                                <span class="cov0" title="0">m.log.Fatal(rvr, debug.Stack())

                                if r.Header.Get("Connection") != "Upgrade" </span><span class="cov0" title="0">{
                                        w.WriteHeader(http.StatusInternalServerError)
                                }</span>
                        }
                }()

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        }

        <span class="cov0" title="0">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package model

type ErrNotFound struct {
        Message string
}

func (e *ErrNotFound) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package httpserver

import (
        "net"
        "time"
)

// Option -.
type Option func(*Server)

// Port -.
func Port(port string) Option <span class="cov0" title="0">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.server.Addr = net.JoinHostPort("", port)
        }</span>
}

// ReadTimeout -.
func ReadTimeout(timeout time.Duration) Option <span class="cov0" title="0">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.server.ReadTimeout = timeout
        }</span>
}

// WriteTimeout -.
func WriteTimeout(timeout time.Duration) Option <span class="cov0" title="0">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.server.WriteTimeout = timeout
        }</span>
}

// ShutdownTimeout -.
func ShutdownTimeout(timeout time.Duration) Option <span class="cov0" title="0">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.shutdownTimeout = timeout
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package httpserver

import (
        "context"
        "net/http"
        "time"
)

const (
        _defaultReadTimeout     = 5 * time.Second
        _defaultWriteTimeout    = 5 * time.Second
        _defaultAddr            = ":80"
        _defaultShutdownTimeout = 3 * time.Second
)

// Server -.
type Server struct {
        server          *http.Server
        notify          chan error
        shutdownTimeout time.Duration
}

// New -.
func New(handler http.Handler, opts ...Option) *Server <span class="cov0" title="0">{
        httpServer := &amp;http.Server{
                Handler:      handler,
                ReadTimeout:  _defaultReadTimeout,
                WriteTimeout: _defaultWriteTimeout,
                Addr:         _defaultAddr,
        }

        s := &amp;Server{
                server:          httpServer,
                notify:          make(chan error, 1),
                shutdownTimeout: _defaultShutdownTimeout,
        }

        // Custom options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(s)
        }</span>

        <span class="cov0" title="0">s.start()

        return s</span>
}

func (s *Server) start() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                s.notify &lt;- s.server.ListenAndServe()
                close(s.notify)
        }</span>()
}

// Notify -.
func (s *Server) Notify() &lt;-chan error <span class="cov0" title="0">{
        return s.notify
}</span>

// Shutdown -.
func (s *Server) Shutdown() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), s.shutdownTimeout)
        defer cancel()

        return s.server.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package logger

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

// Interface -.
type Interface interface {
        Debug(message interface{}, args ...interface{})
        Info(message string, args ...interface{})
        Warn(message string, args ...interface{})
        Error(message interface{}, args ...interface{})
        Fatal(message interface{}, args ...interface{})
        WithFields(fields map[string]interface{}) Interface
}

// Logger -.
type Logger struct {
        logger *logrus.Logger
}

var _ Interface = (*Logger)(nil)

// New -.
func New(level string) *Logger <span class="cov0" title="0">{
        var l logrus.Level

        switch strings.ToLower(level) </span>{
        case "error":<span class="cov0" title="0">
                l = logrus.ErrorLevel</span>
        case "warn":<span class="cov0" title="0">
                l = logrus.WarnLevel</span>
        case "info":<span class="cov0" title="0">
                l = logrus.InfoLevel</span>
        case "debug":<span class="cov0" title="0">
                l = logrus.DebugLevel</span>
        default:<span class="cov0" title="0">
                l = logrus.InfoLevel</span>
        }

        <span class="cov0" title="0">logrus.SetLevel(l)

        logger := logrus.New()

        logger.SetFormatter(&amp;logrus.JSONFormatter{
                TimestampFormat: time.RFC3339Nano,
        })

        return &amp;Logger{
                logger: logger,
        }</span>
}

// Debug -.
func (l *Logger) Debug(message interface{}, args ...interface{}) <span class="cov0" title="0">{
        l.msg("debug", message, args...)
}</span>

// Info -.
func (l *Logger) Info(message string, args ...interface{}) <span class="cov0" title="0">{
        l.log(message, args...)
}</span>

// Warn -.
func (l *Logger) Warn(message string, args ...interface{}) <span class="cov0" title="0">{
        l.log(message, args...)
}</span>

// Error -.
func (l *Logger) Error(message interface{}, args ...interface{}) <span class="cov0" title="0">{
        if l.logger.GetLevel() == logrus.DebugLevel </span><span class="cov0" title="0">{
                l.Debug(message, args...)
        }</span>

        <span class="cov0" title="0">l.msg("error", message, args...)</span>
}

// Fatal -.
func (l *Logger) Fatal(message interface{}, args ...interface{}) <span class="cov0" title="0">{
        l.msg("fatal", message, args...)

        os.Exit(1)
}</span>

func (l *Logger) log(message string, args ...interface{}) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                l.logger.Info(message)
        }</span> else<span class="cov0" title="0"> {
                l.logger.Infof(message, args...)
        }</span>
}

func (l *Logger) msg(level string, message interface{}, args ...interface{}) <span class="cov0" title="0">{
        switch msg := message.(type) </span>{
        case error:<span class="cov0" title="0">
                l.log(msg.Error(), args...)</span>
        case string:<span class="cov0" title="0">
                l.log(msg, args...)</span>
        default:<span class="cov0" title="0">
                l.log(fmt.Sprintf("%s message %v has unknown type %v", level, message, msg), args...)</span>
        }
}

func (l *Logger) WithFields(fields map[string]interface{}) Interface <span class="cov0" title="0">{
        return &amp;Logger{
                logger: l.logger.WithFields(fields).Logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package postgres

import "time"

// Option -.
type Option func(*Postgres)

// MaxPoolSize -.
func MaxPoolSize(size int) Option <span class="cov0" title="0">{
        return func(c *Postgres) </span><span class="cov0" title="0">{
                c.maxPoolSize = size
        }</span>
}

// ConnAttempts -.
func ConnAttempts(attempts int) Option <span class="cov0" title="0">{
        return func(c *Postgres) </span><span class="cov0" title="0">{
                c.connAttempts = attempts
        }</span>
}

// ConnTimeout -.
func ConnTimeout(timeout time.Duration) Option <span class="cov0" title="0">{
        return func(c *Postgres) </span><span class="cov0" title="0">{
                c.connTimeout = timeout
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package postgres implements postgres connection.
package postgres

import (
        "context"
        "fmt"
        "log"
        "time"

        // "github.com/Masterminds/squirrel"
        "github.com/jackc/pgx/v4/pgxpool"
)

const (
        _defaultMaxPoolSize  = 1
        _defaultConnAttempts = 10
        _defaultConnTimeout  = time.Second
)

// Postgres -.
type Postgres struct {
        maxPoolSize  int
        connAttempts int
        connTimeout  time.Duration

        // Builder squirrel.StatementBuilderType
        Pool *pgxpool.Pool
}

// New -.
func New(host, userName, password, dbName string, port int, opts ...Option) (*Postgres, error) <span class="cov0" title="0">{
        pg := &amp;Postgres{
                maxPoolSize:  _defaultMaxPoolSize,
                connAttempts: _defaultConnAttempts,
                connTimeout:  _defaultConnTimeout,
        }

        // Custom options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(pg)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
                host, port, userName, password, dbName)

        poolConfig, err := pgxpool.ParseConfig(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("postgres - NewPostgres - pgxpool.ParseConfig: %w", err)
        }</span>

        <span class="cov0" title="0">poolConfig.MaxConns = int32(pg.maxPoolSize)

        for pg.connAttempts &gt; 0 </span><span class="cov0" title="0">{
                pg.Pool, err = pgxpool.ConnectConfig(context.Background(), poolConfig)
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">log.Printf("Postgres is trying to connect, attempts left: %d", pg.connAttempts)

                time.Sleep(pg.connTimeout)

                pg.connAttempts--</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("postgres - NewPostgres - connAttempts == 0: %w", err)
        }</span>

        <span class="cov0" title="0">return pg, nil</span>
}

// Close -.
func (p *Postgres) Close() <span class="cov0" title="0">{
        if p.Pool != nil </span><span class="cov0" title="0">{
                p.Pool.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package response

import (
        "net/http"

        "films_library/pkg/logger"

        "github.com/mailru/easyjson"
)

const (
        InvalidURLParameter = "invalid url parameter"
        InvalidBodyRequest  = "invalid input body"
        ForbiddenUser       = "user has no rights"
)

// const minErrorToLogCode = 500

//easyjson:json
type Response struct {
        Status int         `json:"status"`
        Body   interface{} `json:"body"`
}

//easyjson:json
type ResponseError struct {
        Status int    `json:"status"`
        ErrMes string `json:"message"`
}

type NilBody struct{}

func NIL() NilBody <span class="cov0" title="0">{
        return NilBody{}
}</span>

func ErrorResponse(w http.ResponseWriter, code int, message string, log logger.Interface) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(code)

        errorMsg := ResponseError{
                Status: code,
                ErrMes: message,
        }

        // if code &lt; minErrorToLogCode {
        //         log.Info("invalid request: %v:", err)
        // } else {
        //         log.Error(err.Error())
        // }

        // Marshal response using easyjson
        _, _, err := easyjson.MarshalToHTTPResponseWriter(errorMsg, w)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Error failed to marshal error message: %s", err.Error())
                w.WriteHeader(http.StatusInternalServerError)

                if _, writeErr := w.Write([]byte("Can't encode error message into json, message: " + message)); writeErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error writing response: %s", writeErr.Error())
                }</span>
        }
}

func SuccessResponse[T any](w http.ResponseWriter, status int, response T) <span class="cov0" title="0">{
        date := Response{Status: status, Body: response}

        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(status)

        // Marshal response using easyjson
        _, _, err := easyjson.MarshalToHTTPResponseWriter(date, w)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)

                return
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
